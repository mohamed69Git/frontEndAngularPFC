{"ast":null,"code":"import { __decorate } from 'tslib';\nimport { FocusMonitor } from '@angular/cdk/a11y';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { UP_ARROW, DOWN_ARROW, ENTER } from '@angular/cdk/keycodes';\nimport { EventEmitter, Component, forwardRef, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, ChangeDetectorRef, Optional, Output, ViewChild, Input, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { isNotNil, InputBoolean } from 'ng-zorro-antd/core/util';\nimport { CommonModule } from '@angular/common';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nimport * as ɵngcc2 from '@angular/cdk/bidi';\nimport * as ɵngcc3 from 'ng-zorro-antd/icon';\nimport * as ɵngcc4 from '@angular/forms';\nconst _c0 = [\"inputElement\"];\nlet NzInputNumberComponent = /*#__PURE__*/(() => {\n  class NzInputNumberComponent {\n    constructor(elementRef, cdr, focusMonitor, directionality) {\n      this.elementRef = elementRef;\n      this.cdr = cdr;\n      this.focusMonitor = focusMonitor;\n      this.directionality = directionality;\n      this.destroy$ = new Subject();\n      this.isFocused = false;\n      this.disabledUp = false;\n      this.disabledDown = false;\n      this.dir = 'ltr';\n\n      this.onChange = () => {};\n\n      this.onTouched = () => {};\n\n      this.nzBlur = new EventEmitter();\n      this.nzFocus = new EventEmitter();\n      this.nzSize = 'default';\n      this.nzMin = -Infinity;\n      this.nzMax = Infinity;\n\n      this.nzParser = value => value.trim().replace(/。/g, '.').replace(/[^\\w\\.-]+/g, '');\n\n      this.nzPrecisionMode = 'toFixed';\n      this.nzPlaceHolder = '';\n      this.nzStep = 1;\n      this.nzInputMode = 'decimal';\n      this.nzId = null;\n      this.nzDisabled = false;\n      this.nzAutoFocus = false;\n\n      this.nzFormatter = value => value; // TODO: move to host after View Engine deprecation\n\n\n      this.elementRef.nativeElement.classList.add('ant-input-number');\n    }\n\n    onModelChange(value) {\n      this.parsedValue = this.nzParser(value);\n      this.inputElement.nativeElement.value = `${this.parsedValue}`;\n      const validValue = this.getCurrentValidValue(this.parsedValue);\n      this.setValue(validValue);\n    }\n\n    getCurrentValidValue(value) {\n      let val = value;\n\n      if (val === '') {\n        val = '';\n      } else if (!this.isNotCompleteNumber(val)) {\n        val = `${this.getValidValue(val)}`;\n      } else {\n        val = this.value;\n      }\n\n      return this.toNumber(val);\n    } // '1.' '1x' 'xx' '' => are not complete numbers\n\n\n    isNotCompleteNumber(num) {\n      return isNaN(num) || num === '' || num === null || !!(num && num.toString().indexOf('.') === num.toString().length - 1);\n    }\n\n    getValidValue(value) {\n      let val = parseFloat(value); // https://github.com/ant-design/ant-design/issues/7358\n\n      if (isNaN(val)) {\n        return value;\n      }\n\n      if (val < this.nzMin) {\n        val = this.nzMin;\n      }\n\n      if (val > this.nzMax) {\n        val = this.nzMax;\n      }\n\n      return val;\n    }\n\n    toNumber(num) {\n      if (this.isNotCompleteNumber(num)) {\n        return num;\n      }\n\n      const numStr = String(num);\n\n      if (numStr.indexOf('.') >= 0 && isNotNil(this.nzPrecision)) {\n        if (typeof this.nzPrecisionMode === 'function') {\n          return this.nzPrecisionMode(num, this.nzPrecision);\n        } else if (this.nzPrecisionMode === 'cut') {\n          const numSplit = numStr.split('.');\n          numSplit[1] = numSplit[1].slice(0, this.nzPrecision);\n          return Number(numSplit.join('.'));\n        }\n\n        return Number(Number(num).toFixed(this.nzPrecision));\n      }\n\n      return Number(num);\n    }\n\n    getRatio(e) {\n      let ratio = 1;\n\n      if (e.metaKey || e.ctrlKey) {\n        ratio = 0.1;\n      } else if (e.shiftKey) {\n        ratio = 10;\n      }\n\n      return ratio;\n    }\n\n    down(e, ratio) {\n      if (!this.isFocused) {\n        this.focus();\n      }\n\n      this.step('down', e, ratio);\n    }\n\n    up(e, ratio) {\n      if (!this.isFocused) {\n        this.focus();\n      }\n\n      this.step('up', e, ratio);\n    }\n\n    getPrecision(value) {\n      const valueString = value.toString();\n\n      if (valueString.indexOf('e-') >= 0) {\n        return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);\n      }\n\n      let precision = 0;\n\n      if (valueString.indexOf('.') >= 0) {\n        precision = valueString.length - valueString.indexOf('.') - 1;\n      }\n\n      return precision;\n    } // step={1.0} value={1.51}\n    // press +\n    // then value should be 2.51, rather than 2.5\n    // if this.props.precision is undefined\n    // https://github.com/react-component/input-number/issues/39\n\n\n    getMaxPrecision(currentValue, ratio) {\n      if (isNotNil(this.nzPrecision)) {\n        return this.nzPrecision;\n      }\n\n      const ratioPrecision = this.getPrecision(ratio);\n      const stepPrecision = this.getPrecision(this.nzStep);\n      const currentValuePrecision = this.getPrecision(currentValue);\n\n      if (!currentValue) {\n        return ratioPrecision + stepPrecision;\n      }\n\n      return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);\n    }\n\n    getPrecisionFactor(currentValue, ratio) {\n      const precision = this.getMaxPrecision(currentValue, ratio);\n      return Math.pow(10, precision);\n    }\n\n    upStep(val, rat) {\n      const precisionFactor = this.getPrecisionFactor(val, rat);\n      const precision = Math.abs(this.getMaxPrecision(val, rat));\n      let result;\n\n      if (typeof val === 'number') {\n        result = ((precisionFactor * val + precisionFactor * this.nzStep * rat) / precisionFactor).toFixed(precision);\n      } else {\n        result = this.nzMin === -Infinity ? this.nzStep : this.nzMin;\n      }\n\n      return this.toNumber(result);\n    }\n\n    downStep(val, rat) {\n      const precisionFactor = this.getPrecisionFactor(val, rat);\n      const precision = Math.abs(this.getMaxPrecision(val, rat));\n      let result;\n\n      if (typeof val === 'number') {\n        result = ((precisionFactor * val - precisionFactor * this.nzStep * rat) / precisionFactor).toFixed(precision);\n      } else {\n        result = this.nzMin === -Infinity ? -this.nzStep : this.nzMin;\n      }\n\n      return this.toNumber(result);\n    }\n\n    step(type, e, ratio = 1) {\n      this.stop();\n      e.preventDefault();\n\n      if (this.nzDisabled) {\n        return;\n      }\n\n      const value = this.getCurrentValidValue(this.parsedValue) || 0;\n      let val = 0;\n\n      if (type === 'up') {\n        val = this.upStep(value, ratio);\n      } else if (type === 'down') {\n        val = this.downStep(value, ratio);\n      }\n\n      const outOfRange = val > this.nzMax || val < this.nzMin;\n\n      if (val > this.nzMax) {\n        val = this.nzMax;\n      } else if (val < this.nzMin) {\n        val = this.nzMin;\n      }\n\n      this.setValue(val);\n      this.updateDisplayValue(val);\n      this.isFocused = true;\n\n      if (outOfRange) {\n        return;\n      }\n\n      this.autoStepTimer = setTimeout(() => {\n        this[type](e, ratio);\n      }, 300);\n    }\n\n    stop() {\n      if (this.autoStepTimer) {\n        clearTimeout(this.autoStepTimer);\n      }\n    }\n\n    setValue(value) {\n      if (`${this.value}` !== `${value}`) {\n        this.onChange(value);\n      }\n\n      this.value = value;\n      this.parsedValue = value;\n      this.disabledUp = this.disabledDown = false;\n\n      if (value || value === 0) {\n        const val = Number(value);\n\n        if (val >= this.nzMax) {\n          this.disabledUp = true;\n        }\n\n        if (val <= this.nzMin) {\n          this.disabledDown = true;\n        }\n      }\n    }\n\n    updateDisplayValue(value) {\n      const displayValue = isNotNil(this.nzFormatter(value)) ? this.nzFormatter(value) : '';\n      this.displayValue = displayValue;\n      this.inputElement.nativeElement.value = `${displayValue}`;\n    }\n\n    onKeyDown(e) {\n      if (e.keyCode === UP_ARROW) {\n        const ratio = this.getRatio(e);\n        this.up(e, ratio);\n        this.stop();\n      } else if (e.keyCode === DOWN_ARROW) {\n        const ratio = this.getRatio(e);\n        this.down(e, ratio);\n        this.stop();\n      } else if (e.keyCode === ENTER) {\n        this.updateDisplayValue(this.value);\n      }\n    }\n\n    writeValue(value) {\n      this.value = value;\n      this.setValue(value);\n      this.updateDisplayValue(value);\n      this.cdr.markForCheck();\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(disabled) {\n      this.nzDisabled = disabled;\n      this.cdr.markForCheck();\n    }\n\n    focus() {\n      this.focusMonitor.focusVia(this.inputElement, 'keyboard');\n    }\n\n    blur() {\n      this.inputElement.nativeElement.blur();\n    }\n\n    ngOnInit() {\n      var _a;\n\n      this.focusMonitor.monitor(this.elementRef, true).pipe(takeUntil(this.destroy$)).subscribe(focusOrigin => {\n        if (!focusOrigin) {\n          this.isFocused = false;\n          this.updateDisplayValue(this.value);\n          this.nzBlur.emit();\n          Promise.resolve().then(() => this.onTouched());\n        } else {\n          this.isFocused = true;\n          this.nzFocus.emit();\n        }\n      });\n      this.dir = this.directionality.value;\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n      });\n    }\n\n    ngOnChanges(changes) {\n      if (changes.nzFormatter && !changes.nzFormatter.isFirstChange()) {\n        const validValue = this.getCurrentValidValue(this.parsedValue);\n        this.setValue(validValue);\n        this.updateDisplayValue(validValue);\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.nzAutoFocus) {\n        this.focus();\n      }\n    }\n\n    ngOnDestroy() {\n      this.focusMonitor.stopMonitoring(this.elementRef);\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  NzInputNumberComponent.ɵfac = function NzInputNumberComponent_Factory(t) {\n    return new (t || NzInputNumberComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8));\n  };\n\n  NzInputNumberComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NzInputNumberComponent,\n    selectors: [[\"nz-input-number\"]],\n    viewQuery: function NzInputNumberComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function NzInputNumberComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ant-input-number-focused\", ctx.isFocused)(\"ant-input-number-lg\", ctx.nzSize === \"large\")(\"ant-input-number-sm\", ctx.nzSize === \"small\")(\"ant-input-number-disabled\", ctx.nzDisabled)(\"ant-input-number-rtl\", ctx.dir === \"rtl\");\n      }\n    },\n    inputs: {\n      nzSize: \"nzSize\",\n      nzMin: \"nzMin\",\n      nzMax: \"nzMax\",\n      nzParser: \"nzParser\",\n      nzPrecisionMode: \"nzPrecisionMode\",\n      nzPlaceHolder: \"nzPlaceHolder\",\n      nzStep: \"nzStep\",\n      nzInputMode: \"nzInputMode\",\n      nzId: \"nzId\",\n      nzDisabled: \"nzDisabled\",\n      nzAutoFocus: \"nzAutoFocus\",\n      nzFormatter: \"nzFormatter\",\n      nzPrecision: \"nzPrecision\"\n    },\n    outputs: {\n      nzBlur: \"nzBlur\",\n      nzFocus: \"nzFocus\"\n    },\n    exportAs: [\"nzInputNumber\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => NzInputNumberComponent),\n      multi: true\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 8,\n    vars: 13,\n    consts: [[1, \"ant-input-number-handler-wrap\"], [\"unselectable\", \"unselectable\", 1, \"ant-input-number-handler\", \"ant-input-number-handler-up\", 3, \"mousedown\", \"mouseup\", \"mouseleave\"], [\"nz-icon\", \"\", \"nzType\", \"up\", 1, \"ant-input-number-handler-up-inner\"], [\"unselectable\", \"unselectable\", 1, \"ant-input-number-handler\", \"ant-input-number-handler-down\", 3, \"mousedown\", \"mouseup\", \"mouseleave\"], [\"nz-icon\", \"\", \"nzType\", \"down\", 1, \"ant-input-number-handler-down-inner\"], [1, \"ant-input-number-input-wrap\"], [\"autocomplete\", \"off\", 1, \"ant-input-number-input\", 3, \"disabled\", \"placeholder\", \"ngModel\", \"keydown\", \"keyup\", \"ngModelChange\"], [\"inputElement\", \"\"]],\n    template: function NzInputNumberComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"span\", 1);\n        ɵngcc0.ɵɵlistener(\"mousedown\", function NzInputNumberComponent_Template_span_mousedown_1_listener($event) {\n          return ctx.up($event);\n        })(\"mouseup\", function NzInputNumberComponent_Template_span_mouseup_1_listener() {\n          return ctx.stop();\n        })(\"mouseleave\", function NzInputNumberComponent_Template_span_mouseleave_1_listener() {\n          return ctx.stop();\n        });\n        ɵngcc0.ɵɵelement(2, \"i\", 2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(3, \"span\", 3);\n        ɵngcc0.ɵɵlistener(\"mousedown\", function NzInputNumberComponent_Template_span_mousedown_3_listener($event) {\n          return ctx.down($event);\n        })(\"mouseup\", function NzInputNumberComponent_Template_span_mouseup_3_listener() {\n          return ctx.stop();\n        })(\"mouseleave\", function NzInputNumberComponent_Template_span_mouseleave_3_listener() {\n          return ctx.stop();\n        });\n        ɵngcc0.ɵɵelement(4, \"i\", 4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(5, \"div\", 5);\n        ɵngcc0.ɵɵelementStart(6, \"input\", 6, 7);\n        ɵngcc0.ɵɵlistener(\"keydown\", function NzInputNumberComponent_Template_input_keydown_6_listener($event) {\n          return ctx.onKeyDown($event);\n        })(\"keyup\", function NzInputNumberComponent_Template_input_keyup_6_listener() {\n          return ctx.stop();\n        })(\"ngModelChange\", function NzInputNumberComponent_Template_input_ngModelChange_6_listener($event) {\n          return ctx.onModelChange($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"ant-input-number-handler-up-disabled\", ctx.disabledUp);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵclassProp(\"ant-input-number-handler-down-disabled\", ctx.disabledDown);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.nzDisabled)(\"placeholder\", ctx.nzPlaceHolder)(\"ngModel\", ctx.displayValue);\n        ɵngcc0.ɵɵattribute(\"id\", ctx.nzId)(\"autofocus\", ctx.nzAutoFocus ? \"autofocus\" : null)(\"min\", ctx.nzMin)(\"max\", ctx.nzMax)(\"step\", ctx.nzStep)(\"inputmode\", ctx.nzInputMode);\n      }\n    },\n    directives: [ɵngcc3.NzIconDirective, ɵngcc4.DefaultValueAccessor, ɵngcc4.NgControlStatus, ɵngcc4.NgModel],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([InputBoolean()], NzInputNumberComponent.prototype, \"nzDisabled\", void 0);\n\n  __decorate([InputBoolean()], NzInputNumberComponent.prototype, \"nzAutoFocus\", void 0);\n\n  return NzInputNumberComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzInputNumberModule = /*#__PURE__*/(() => {\n  class NzInputNumberModule {}\n\n  NzInputNumberModule.ɵfac = function NzInputNumberModule_Factory(t) {\n    return new (t || NzInputNumberModule)();\n  };\n\n  NzInputNumberModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NzInputNumberModule\n  });\n  NzInputNumberModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, FormsModule, NzIconModule]]\n  });\n  return NzInputNumberModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NzInputNumberModule, {\n    declarations: function () {\n      return [NzInputNumberComponent];\n    },\n    imports: function () {\n      return [BidiModule, CommonModule, FormsModule, NzIconModule];\n    },\n    exports: function () {\n      return [NzInputNumberComponent];\n    }\n  });\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzInputNumberComponent, NzInputNumberModule }; //# sourceMappingURL=ng-zorro-antd-input-number.js.map","map":null,"metadata":{},"sourceType":"module"}